{"version":3,"sources":["snake/game.js.js"],"names":["Game","constructor","boardWidth","boardHeight","this","opts","baitLocation","row","col","Array","map","board","push","snake","Snake","addSnake","newBait","set","pos","x","y","val","get","positions","forEach","curVal","Math","floor","random","createVector","step","oldPositions","newPositions","move","status","updateBoard","prevPos","curPos","bait","pre","cur","i","positionsCopy","curPiece","splice","rest","o","length","other","equals"],"mappings":"AAAA,MAAMA,KACJC,YAAYC,EAAYC,GACtBC,KAAKC,KAAO,CAAAH,WAAAA,EAAAC,YAAAA,GAAED,KAAAA,MAAF,GAAcC,KAAAA,aAAAA,KAE1B,IAAKG,IAAAA,EAAAA,EAALC,EAAAL,EAEAK,IAAA,CAEE,IAAIC,EAAM,IAAIC,MAAMN,IAAcO,IAAI,IAAM,GAD9CN,KAAKO,MAAOC,KAAML,GAEhBM,MAAKF,IAALG,MAAgBN,KAAhBH,MACDD,KAAAW,SAAAF,OAGDT,KAAKY,UAALC,IAAAC,EAAKF,GACNZ,KAAAO,MAAAO,EAAAC,GAAAD,EAAAE,GAAAC,EAGCC,IAAAJ,GACD,OAAAd,KAAAO,MAAAO,EAAAC,GAAAD,EAAAE,GAGCL,SAAOF,GACRA,EAAAU,UAAAC,QAAAN,GAAAd,KAAAa,IAAAC,GAAA,IAGCL,UACD,IAIKK,EAJLO,GAAA,EAEDT,MAAU,IAAHS,GAAG,IAAAA,GAAA,CACR,IAAIA,EAAMC,KAAVC,MAAAC,OAAAxB,KAAAC,KAAAH,aACIgB,EAAJQ,KAAAC,MAAAC,OAAAxB,KAAAC,KAAAF,cAIEe,EAAMW,aAAaV,EAAGC,GAHxBK,EAAOA,KAAMH,IAANJ,GAELd,KAAAE,aAAQY,EACRA,KAAGD,IAAGY,EAAAA,GAOVC,OAJE,IAAAC,aAAKzB,EAAL0B,aAAoBd,GAApBL,MAAAoB,OAEDC,EAAA9B,KAAA+B,YAMGJ,EAJAC,EACF5B,KAAIE,cAOJ,OAPoB0B,IAAAA,IAAhBnB,MAAiCA,OAErCT,KAAI8B,WAKAA,EAGHC,YAAAC,EAAAC,EAAAC,GAKD,IAJAF,EAAOF,QAAPK,GAAAnC,KAAAa,IAAAsB,EAAA,IACDF,EAAAb,QAAAgB,GAAApC,KAAAa,IAAAuB,GAAA,IAMG,MAJJL,OAAYC,EAERA,IAAAA,EAAiBG,IAADF,GAChBA,IAAAA,IAAOb,EAAAA,EAAPiB,EAAeC,EAAkBF,OAAjCC,IAAA,CACA,IAAAE,EAAMD,EAAAD,GACNC,EAAAE,OAAAH,EAAA,GACD,IAAAI,EAAAH,EAQC,IAAK,IAAII,EAAI,EAAGA,EAAID,EAAKE,OAAQD,IAAK,CANxC,IAAKE,EAAWP,EAAIC,GAElBA,GAAAA,EAAcE,OAAdI,GACIH,OAAOH,EAWX,OALEC,EAAIA,GAASM,KAAT5C,KAAgB2C,YAClBL,EAAOxB,EAAP,GACDwB,EAAAvB,GAAAhB,KAAAC,KAAAF,aAEHwC,EAAAvB,EAAA,GAOU,EAENuB,EAASM,OAAOX,GAAhBK,EAEH","file":"../../snake/game.js.min.js","sourcesContent":["class Game {\n  constructor(boardWidth, boardHeight) {\n    this.opts = { boardWidth, boardHeight }\n    this.board = []\n    this.baitLocation = null\n\n    // init board\n    for (let row = 0; row < boardWidth; row++) {\n      let col = [...Array(boardHeight)].map(() => 0)\n      this.board.push(col)\n    }\n    snake = new Snake(this.opts)\n    this.addSnake(snake)\n    this.newBait()\n  }\n\n  set(pos, val) {\n    this.board[pos.x][pos.y] = val\n  }\n\n  get(pos) {\n    return this.board[pos.x][pos.y]\n  }\n\n  addSnake(snake) {\n    snake.positions.forEach((pos) => this.set(pos, -1))\n  }\n\n  newBait() {\n    let curVal = -1\n    let pos\n    while (curVal === -1 || curVal === 1) {\n      let x = Math.floor(random(this.opts.boardWidth))\n      let y = Math.floor(random(this.opts.boardHeight))\n      pos = createVector(x, y)\n      curVal = this.get(pos)\n    }\n    this.baitLocation = pos\n    this.set(pos, 1)\n  }\n\n  step() {\n    let { oldPositions, newPositions } = snake.move()\n\n    let status = this.updateBoard(\n      oldPositions,\n      newPositions,\n      this.baitLocation\n    )\n    if (status === 1) {\n      snake.grow()\n      this.newBait()\n    }\n    return status\n  }\n\n  updateBoard(prevPos, curPos, bait) {\n    try {\n      prevPos.forEach((pre) => this.set(pre, 0))\n      curPos.forEach((cur) => this.set(cur, -1))\n    } catch {\n      return -1\n    }\n    let positionsCopy = [...curPos]\n    for (let i = 0; i < positionsCopy.length; i++) {\n      let curPiece = positionsCopy[i]\n      positionsCopy.splice(i, 1)\n      let rest = positionsCopy\n      // runs into itself\n\n      for (let o = 0; o < rest.length; o++) {\n        let other = rest[o]\n\n        if (curPiece.equals(other)) {\n          return -1\n        }\n      }\n      // out of bounds\n      if (\n        curPiece.x >= this.opts.boardWidth ||\n        curPiece.x < 0 ||\n        curPiece.y >= this.opts.boardHeight ||\n        curPiece.y < 0\n      )\n        return -1\n      // finds bait\n      if (curPiece.equals(bait)) {\n        return 1\n      }\n      return 0\n    }\n  }\n}"]}