{"version":3,"sources":["snake2/snake.js"],"names":["Snake","constructor","ctx","p","rows","cols","createVector","Math","floor","this","initialPos","snakeLife","headPos","positions","life","length","brain","heading","addBrain","scan","b","think","predict","scanValues","reduce","a","v","i","prediction","decision","Infinity","setHeading","newHeading","x","y","combined","add","move","newPositions","push","curPos","shouldGrow","oldPositions","grow","look","board","sightSize","scanObj","start","curCol","end","scanVector","cur","p5","Vector","val","undefined","_headPos"],"mappings":"AAAA,MAAMA,MACJC,YAAYC,GACV,IAAIC,EAAAA,EAAAC,KAAAA,EAAAC,KAAAA,GAAAH,EAACC,KAADD,IAAAA,EAAIE,IAAAA,EAAJD,EAAAG,aAAAC,KAAAC,OAAAH,EAAA,GAAA,GAAAE,KAAAC,OAAAJ,EAAA,GAAA,IAAUC,KAAAA,QAAAA,EAAVI,KAAkBP,UAAtB,CAAAQ,GACAD,KAAKP,KAAMA,EAAXS,UAEAF,KAAKG,MAAL,KACAH,KAAKI,QAALV,EAAiBG,aAAjB,EAAA,GACAG,KAAKK,OAAOZ,KAAIS,UAAhBI,OAEAN,KAAKO,YAAL,EACAP,KAAKQ,KAAL,GAGAC,SAAKC,GACNV,KAAAO,MAAAI,EAGCC,QAQI,OAPLZ,KAAAO,MAAAM,QAAAb,KAAAU,KAAAI,YAEMC,OAAA,CAAAC,EAAAC,EAAAC,KACDC,EAAAA,IAEAC,CAAAA,KAAQC,EAAAA,EAAGF,EAAWJ,KAAXG,GAGSA,KAAG,EAAKA,KAEhCI,WAAA,GAAA,GAKI,MAHF,KAAA,EACAtB,KAAAsB,WAAA,EAAA,GACE,MAEF,KAAA,EAMEtB,KAAKsB,WAAW,EAAE,GALpB,MAEE,KAAA,EACFtB,KAAAsB,YAAA,EAAA,GAOE,MANF,QACEtB,KAAKsB,WAAW,EAAhB,IAIAA,WAAKA,EAAAA,GACL,IAAA5B,EAAAA,GAAAM,KAAAP,IASA8B,EAAa7B,EAAEG,aAAa2B,EAAGC,GARjCC,EAAA1B,KAAAQ,QAAAmB,IAAAJ,GAEE,GAAA,IAAAG,EAAAF,GAAA,IAAAE,EAAAD,EAEL,OArBCzB,KAAAQ,QAAAe,EAqBDvB,KAAAQ,QAGCoB,OAAKlC,IAAAA,EAAAA,KAAAA,UAAAA,IAAAA,GAAAA,EAAAA,QAAKmC,EAAV,GACA,IAAIN,IAAAA,EAAAA,EAAUL,EAAKrB,KAAAA,UAAgB4B,OAAnCP,IAAA,CACA,IAAIQ,EAAW1B,KAAKQ,UAAQmB,GAAIJ,OAY9B,GAAU,IAANL,GATN,GADIQ,EAAAI,KAAAC,EAAoBL,IAASD,KAATjB,UACnBA,KAALwB,WAAA,CACAH,EAAAC,QAAA9B,KAAAI,WACD,YAGK6B,EAAYH,KAAG9B,KAAKI,UAALc,EAAmB,IAKlCW,OAHJ7B,KAAKgC,YAAY,EACfhC,KAAAG,QAAa0B,EAAKzB,GAapBJ,KAAKI,UAAYyB,EAZf7B,KAAAK,MAAA,EACEwB,CAcFA,aAAAA,EAbEI,aAAAA,GAIDC,OACCL,KAAAA,YAAaC,EACd9B,KAAAK,MAAA,IAEH8B,KAAAC,GACA,IAAAC,UAAKlC,EAALT,EAAemC,GAAAA,KAAAA,IACfS,EAAA,GACAxB,EAAA,GACAyB,GAAO,EAAAzC,KAAAC,MAAAsC,EAAA,GACLR,EAAAA,KADK9B,MAAAsC,EAAA,GAELJ,IAAAA,IAAAA,EAAAA,EAAAA,GAAAA,EAAAA,IAAAA,CAFF,IAAAO,EAAA,GAID,IAAA,IAAAf,EAAAc,EAAAd,GAAAgB,EAAAhB,IAAA,CAgBK,IAbCO,EAaGU,EAAahD,EAAEG,aAAa2B,EAAGC,GAdlCkB,EAAAC,GAAAC,OAAAlB,IAAAe,EAAA1C,KAAAG,SAEL,IACD2C,EAAAV,EAAAO,EAAAnB,GAAAmB,EAAAlB,GAgBO,MAdHW,GAAM,OACLW,IAACV,IAADS,GAAA,GAAYpD,EAAAA,GAAAA,KAAAA,QAAAA,EAAAA,KAAAA,EAAAA,KAAAA,EAAK4C,EAArBU,SAAAhD,KAAAG,QACImC,EAAOR,KAAXgB,GAEAhC,EAAYhB,KAAKC,GAEjB,OAkBAC,KAAKU,KAAO,CAACI,WAAAA,EAAYwB,QAAAA,GAlBrBtC,KAAKU","file":"../../snake2/snake.min.js","sourcesContent":["class Snake {\n  constructor(ctx) {\n    let {p, rows, cols} = ctx\n    this.ctx = ctx\n    let initialPos = p.createVector(Math.floor((cols-1)/2), Math.floor((rows-1)/2))\n    this.headPos = initialPos\n    this.positions = [initialPos]\n    this.life = ctx.snakeLife\n\n    this.brain = null\n    this.heading = p.createVector(1,0)\n    this.length = this.positions.length\n    this.shouldGrow = false\n    this.scan = {}\n  }\n\n  addBrain(b){\n    this.brain = b\n  }\n\n  think(){\n    let prediction = this.brain.predict(this.scan.scanValues)\n    // figure out which index has the highest value\n    let decision = prediction.reduce((a, v, i) => (\n      v > a.val\n      ? {val: v, i:i}\n      : a, {val: -Infinity, i: 0})).i\n\n    // assign that index a direction\n    switch(decision) {\n      // up\n      case 0:\n        this.setHeading(0,-1)\n        break;\n      // right\n      case 1:\n        this.setHeading(1,0)\n        break;\n      // down\n      case 2:\n        this.setHeading(0,1)\n        break;\n      // left\n      case 3:\n        this.setHeading(-1,0)\n        break;\n      default:\n        this.setHeading(1,0)\n        break;\n    }\n  }\n\n  setHeading(x, y) {\n    let {p} = this.ctx\n    let newHeading = p.createVector(x, y)\n    let combined = this.heading.add(newHeading)\n    // cant go backwards\n    if (combined.x === 0 && combined.y === 0) return\n    this.heading = newHeading\n    return this.heading\n  }\n\n  move() {\n    let oldPositions = this.positions.map((p) => p.copy())\n    let newPositions = []\n    for (let i = 0; i < this.positions.length; i++) {\n      let curPos = this.positions[i].copy()\n      if (i === 0) {\n        newPositions.push(curPos.add(this.heading))\n        if (this.shouldGrow) {\n          newPositions.push(...this.positions)\n          break\n        }\n      } else {\n        newPositions.push(this.positions[i - 1])\n      }\n    }\n    this.shouldGrow = false\n    this.headPos = newPositions[0]\n    this.positions = newPositions\n    this.life -= 1\n    return {\n      newPositions,\n      oldPositions,\n    }\n  }\n\n  grow() {\n    this.shouldGrow = true\n    this.life += 100\n  }\n\n  look(board){\n    let {sightSize, p} = this.ctx\n    let scanObj = {}\n    let scanValues = []\n    let start = Math.floor(sightSize/2) * -1\n    let end = Math.floor(sightSize/2)\n    for(let x = start; x <= end; x++) {\n      let curCol = []\n      for(let y = start; y <= end; y++) {\n        let scanVector = p.createVector(x, y)\n        let cur = p5.Vector.add(scanVector, this.headPos)\n        let val\n        try {\n          val = board[cur.x][cur.y]\n        } catch {\n          val = -1\n        }\n        if(val === undefined) val = -1\n        scanObj[`${x},${y} -- ${cur.x},${cur.y}`] = val\n        scanObj._headPos = this.headPos\n        curCol.push(val)\n      }\n      scanValues.push(curCol)\n    }\n    this.scan = {scanValues, scanObj}\n    return this.scan\n  }\n}\n"]}