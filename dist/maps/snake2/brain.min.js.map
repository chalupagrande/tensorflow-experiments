{"version":3,"sources":["snake2/brain.js"],"names":["Brain","constructor","ctx","this","model","createModel","sightSize","nnHiddenLayers","nnHiddenNodes","nnActivationFunc","nnLearningRate","nnOptimizer","nnLoss","tf","setBackend","layers","i","units","activation","dense","push","optimizer","train","sequential","loss","metrics","input","predict","tensor","flat","dataSync"],"mappings":"AAAA,MAAMA,MACJC,YAAYC,GACVC,KAAKD,IAAMA,EACXC,KAAKC,MAAQD,KAAKE,cAGpBA,cACE,IAAIC,UACFA,EADEC,eAEFA,EAFEC,cAGFA,EAHEC,iBAIFA,EAJEC,eAKFA,EALEC,YAMFA,EANEC,OAOFA,GACET,KAAKD,IAITW,GAAAC,WAAa,OAEb,IAAAC,EAAY,GAEV,IAAA,IAAKC,EAAI,EAAAA,EAADT,EACJS,IAAgB,CAAsCC,IAAAA,EAAOT,IAAFQ,EAAiBE,GAAAA,OAAYT,MAAAA,CAAAA,WAAAA,CAAAA,EAAAA,GAAAA,MAAAA,EAAAA,WAAAA,IADpFI,GAEFE,OAAFI,MAAA,CAAgBF,MAAAT,EAAAU,WAAA,YAACD,EAAKG,KAAEZ,GAE7BO,EACDK,KAAAP,GAAAE,OAAAI,MAAA,CAAAF,MAAA,KACA,MAAAI,EAAAR,GAAAS,MAAAX,GAAAD,GAIMN,EAAQS,GAAGU,WAAW,CAACR,OAAAA,IAAD,OAHCE,EAAAA,QAAO,CAApCI,UAAAA,EACAG,KAAMH,GAAAA,OAAYR,GAElBY,QAAW,CAAA,cAAXrB,EAIEoB,QAAIE,GAFQ,OAGFvB,KAAAC,MAADuB,QAAAd,GAAAe,OAAA,CAAAF,EAAAG,UAHXC","file":"../../snake2/brain.min.js","sourcesContent":["class Brain {\n  constructor(ctx){\n    this.ctx = ctx\n    this.model = this.createModel()\n  }\n\n  createModel() {\n    let {\n      sightSize,\n      nnHiddenLayers,\n      nnHiddenNodes,\n      nnActivationFunc,\n      nnLearningRate,\n      nnOptimizer,\n      nnLoss\n    } = this.ctx\n\n    tf.setBackend('cpu')\n\n    let layers = []\n    // create hidden layers\n    for(let i = 0; i < nnHiddenLayers; i++) {\n      // if it is the first layer, define input shape\n      let l = i === 0\n        ? tf.layers.dense({inputShape: [sightSize * sightSize], units: nnHiddenNodes, activation: nnActivationFunc})\n        : tf.layers.dense({units: nnHiddenNodes, activation: 'softmax'})\n      layers.push(l)\n    }\n    // create output layer\n    // units = 4 because left, down, up, right\n    layers.push(tf.layers.dense({units: 4}))\n    const optimizer = tf.train[nnOptimizer](nnLearningRate);\n\n    const model = tf.sequential({layers})\n\n    model.compile({\n      optimizer: optimizer,\n      loss: tf.losses[nnLoss],\n      metrics: ['accuracy']\n    })\n    return model\n  }\n\n  predict(input){\n    let output = this.model.predict(tf.tensor([input.flat()]))\n    return output.dataSync()\n  }\n}"]}