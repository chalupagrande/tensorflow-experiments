{"version":3,"sources":["test.js"],"names":["settings","activation","learningRate","optimizer","loss","getModel","model","tf","sequential","layers","inputShape","dense","units","train","losses","newWeightArray","layersLength","length","i","setWeights","j","weights","getWeights","log","memory","shape","weightData","dataSync","newWeights","Array","map","Math","random","push","tensor","tidy","prediction","predict","console","randomizeWeights"],"mappings":"AAAA,IAAIA,SAAW,CACbC,WAAY,OACZC,aAAc,GACdC,UAAW,MACXC,KAAM,oBAGR,SAASC,WACP,MAAMC,EAAQC,GAAGC,WAAW,CAC1BC,OAAQ,CACWC,GAAAA,OAAUC,MAAX,CAAAD,WAAA,CAAA,GAAAE,MAAA,EAAAX,WAAAD,SAAAC,aAAkBW,GAAAA,OAAlBD,MAAA,CAAAC,MAAA,OADVV,EAAAF,SAAAE,aADVC,EAAAI,GAAAM,MAAAb,SAAAG,WAAAD,GAgBA,OARAI,EAAMH,QAAAA,CAENG,UAAAH,EACEA,KAAAA,GAASW,OAAEX,SADCC,MAEZA,QAASU,CAAAA,cAIJR,EA0CHS,SAAAA,iBAAoBR,GACrB,IAAAS,EAAAV,EAAAG,OAAAQ,OACDX,IAAAA,IAAMG,EAAAA,EAANS,EAAgBC,EAAWJ,IAAAA,CAC5B,IAAAA,EAAA,GACF,IAAA,IAAAK,EAAA,EAAAA,EAAA,EAAAA,IAAA,CATK,IAAIC,EAAUf,EAAMG,OAAOS,GAAGI,aAAaF,GAWzCG,EAAOC,EAAfC,MATUC,EAAaL,EAAQM,WAErBC,EAAa,IAAIC,MAAMH,EAAWT,SAASa,IAAI,IAAsB,EAAhBC,KAAKC,SAAe,GAC7EjB,EAAekB,KAAK1B,GAAG2B,OAAON,EAAYH,IAE5CnB,EAAMG,OAAOS,GAAGC,WAAWJ,IAzC/BR,GAAG4B,KAAK,KACN,IAAI7B,EAAQD,WACR+B,EAAa9B,EAAM+B,QAAQ9B,GAAG2B,OAAO,CAAC,CAAC,EAAD,MAC1CI,QAAQf,IAAK,iBAAgBa,EAAWT,YAGxCW,EAAahC,EAAA+B,QAAA9B,GAAgB6B,OAAAA,CAAAA,CAAU,EAACT,MAExCY,QAAAA,IAAAA,iBAAAH,EAAAT,YAGAW,iBAAahC,GAKb8B,EAAa9B,EAAM+B,QAAQ9B,GAAG2B,OAAO,CAAC,CAAC,EAAD,MACtCI,QAAQf,IAAK,iBAAgBa,EAAWT,YAKxCW,iBAAahC,GANb8B,EAAa9B,EAAM+B,QAAQ9B,GAAG2B,OAAO,CAAC,CAAC,EAAE,MAY3CI,QAASC,IAAAA,iBAATH,EAAgCT,YAT9BY,iBAAiBjC,GAaf8B,EAAIrB,EAAAA,QAAJR,GAAA2B,OAAA,CAAA,CAAA,EAAA,MAVFI,QAAQf,IAAK,iBAAgBa,EAAWT,cAuB1CW,QAAQf,IAAIhB,GAAGiB","file":"../test.min.js","sourcesContent":["let settings = {\n  activation: 'relu',\n  learningRate: 0.2,\n  optimizer: 'sgd',\n  loss: 'meanSquaredError'\n}\n\nfunction getModel(){\n  const model = tf.sequential({\n    layers: [\n      tf.layers.dense({inputShape: [2], units: 4, activation: settings.activation}),\n      tf.layers.dense({units: 1}),\n    ]\n   });\n\n  const learningRate = settings.learningRate\n  const optimizer = tf.train[settings.optimizer](learningRate);\n\n  model.compile({\n    optimizer: optimizer,\n    loss: tf.losses[settings.loss],\n    metrics: ['accuracy']\n  })\n\n  return model\n}\n\ntf.tidy(()=> {\n  let model = getModel()\n  let prediction = model.predict(tf.tensor([[0,1]]))\n  console.log(`prediction 1: ${prediction.dataSync()}`)\n\n  prediction = model.predict(tf.tensor([[0,1]]))\n  console.log(`prediction 2: ${prediction.dataSync()}`)\n\n  randomizeWeights(model)\n\n  prediction = model.predict(tf.tensor([[0,1]]))\n  console.log(`prediction 3: ${prediction.dataSync()}`)\n\n\n  randomizeWeights(model)\n\n  prediction = model.predict(tf.tensor([[0,1]]))\n  console.log(`prediction 4: ${prediction.dataSync()}`)\n\n  randomizeWeights(model)\n\n  prediction = model.predict(tf.tensor([[0,1]]))\n  console.log(`prediction 5: ${prediction.dataSync()}`)\n\n\n\n})\n\nfunction randomizeWeights(model){\n  let layersLength = model.layers.length\n  // iterate over layers\n  for (let i = 0; i < layersLength; i++) {\n    let newWeightArray = []\n    for (let j = 0; j < 2; j++) {\n      let weights = model.layers[i].getWeights()[j]\n      let shape = weights.shape\n      let weightData = weights.dataSync()\n\n      let newWeights = [...Array(weightData.length)].map(() => Math.random() * 2 - 1)\n      newWeightArray.push(tf.tensor(newWeights, shape))\n    }\n    model.layers[i].setWeights(newWeightArray)\n  }\n}\n\nconsole.log(tf.memory())\n"]}