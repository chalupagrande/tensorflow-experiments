{"version":3,"sources":["test.js"],"names":["settings","activation","learningRate","optimizer","loss","getModel","model","tf","sequential","layers","inputShape","dense","units","train","losses","randomizeWeights","layersLength","weights","shape","length","newWeights","weightData","newWeightArray","j","i","getWeights","setWeights","dataSync","slice","Array","map","Math","random","console","push","tensor","tidy","prediction","predict","log","memory"],"mappings":"AAAA,IAAIA,SAAW,CACbC,WAAY,OACZC,aAAc,GACdC,UAAW,MACXC,KAAM,oBAGR,SAASC,WACP,MAAMC,EAAQC,GAAGC,WAAW,CAC1BC,OAAQ,CACWC,GAAAA,OAAUC,MAAX,CAAAD,WAAA,CAAA,GAAAE,MAAA,EAAAX,WAAAD,SAAAC,aAAkBW,GAAAA,OAAlBD,MAAA,CAAAC,MAAA,OADVV,EAAAF,SAAAE,aADVC,EAAAI,GAAAM,MAAAb,SAAAG,WAAAD,GAgBA,OARAI,EAAMH,QAAAA,CAENG,UAAAH,EACEA,KAAAA,GAASW,OAAEX,SADCC,MAEZA,QAASU,CAAAA,cAIJR,EAiCH,SAAAS,iBAAoBN,GACpB,IAAAO,EAAYC,EAAQC,OAApBC,OAGA,IAAA,IAAIC,EAAAA,EAAAA,EAAUJ,EAAaK,IAAAA,CAC3BC,IAAAA,EAAA,GACD,IAAA,IAAAC,EAAA,EAAAA,EAAA,EAAAA,IAAA,CANC,IAAIN,EAAUX,EAAMG,OAAOe,GAAGC,aAAaF,GAOvCd,EAANQ,EAAgBS,MACjBL,EAAAJ,EAAAU,WAAAC,QAJOR,EAAa,IAAIS,MAAMR,EAAWF,SAASW,IAAI,IAAsB,EAAhBC,KAAKC,SAAe,GAOnFC,EAAYC,KAAZ3B,GAAA4B,OAAAf,EAAAF,IAJIZ,EAAMG,OAAOe,GAAGE,WAAWJ,IArC/Bf,GAAG6B,KAAK,KACN,IAAI9B,EAAQD,WACRgC,EAAa/B,EAAMgC,QAAQ/B,GAAG4B,OAAO,CAAC,CAAC,EAAD,MAC1CF,QAAQM,IAAK,iBAAgBF,EAAWV,YAGxCM,EAAa3B,EAAAgC,QAAA/B,GAAgB8B,OAAAA,CAAAA,CAAU,EAACV,MAExCZ,QAAAA,IAAAA,iBAAAsB,EAAAV,YAGAM,iBAAa3B,GAIb+B,EAAa/B,EAAMgC,QAAQ/B,GAAG4B,OAAO,CAAC,CAAC,EAAD,MACtCF,QAAQM,IAAK,iBAAgBF,EAAWV,YAIxCU,iBAAa/B,GApBf+B,EAAA/B,EAAAgC,QAAA/B,GAAA4B,OAAA,CAAA,CAAA,EAAA,MAgBEF,QAAQM,IAAK,iBAAgBF,EAAWV,YASxCZ,iBAAgBT,GAEhB+B,EAAa/B,EAAIgC,QAAGtB,GAAAA,OAApB,CAAA,CAAuC,EAAA,MACrCiB,QAAIX,IAAAA,iBAAJe,EAAAV,cAaJM,QAAQM,IAAIhC,GAAGiC","file":"../test.min.js","sourcesContent":["let settings = {\n  activation: 'relu',\n  learningRate: 0.2,\n  optimizer: 'sgd',\n  loss: 'meanSquaredError'\n}\n\nfunction getModel(){\n  const model = tf.sequential({\n    layers: [\n      tf.layers.dense({inputShape: [2], units: 4, activation: settings.activation}),\n      tf.layers.dense({units: 1}),\n    ]\n   });\n\n  const learningRate = settings.learningRate\n  const optimizer = tf.train[settings.optimizer](learningRate);\n\n  model.compile({\n    optimizer: optimizer,\n    loss: tf.losses[settings.loss],\n    metrics: ['accuracy']\n  })\n\n  return model\n}\n\ntf.tidy(()=> {\n  let model = getModel()\n  let prediction = model.predict(tf.tensor([[0,1]]))\n  console.log(`prediction 1: ${prediction.dataSync()}`)\n\n  prediction = model.predict(tf.tensor([[0,1]]))\n  console.log(`prediction 2: ${prediction.dataSync()}`)\n\n  randomizeWeights(model)\n\n  prediction = model.predict(tf.tensor([[0,1]]))\n  console.log(`prediction 3: ${prediction.dataSync()}`)\n\n  randomizeWeights(model)\n\n  prediction = model.predict(tf.tensor([[0,1]]))\n  console.log(`prediction 4: ${prediction.dataSync()}`)\n\n  randomizeWeights(model)\n\n  prediction = model.predict(tf.tensor([[0,1]]))\n  console.log(`prediction 5: ${prediction.dataSync()}`)\n})\n\nfunction randomizeWeights(model){\n  let layersLength = model.layers.length\n  // iterate over layers\n  for (let i = 0; i < layersLength; i++) {\n    let newWeightArray = []\n    for (let j = 0; j < 2; j++) {\n      let weights = model.layers[i].getWeights()[j]\n      let shape = weights.shape\n      let weightData = weights.dataSync().slice()\n\n      let newWeights = [...Array(weightData.length)].map(() => Math.random() * 2 - 1)\n      newWeightArray.push(tf.tensor(newWeights, shape))\n    }\n    model.layers[i].setWeights(newWeightArray)\n  }\n}\n\nconsole.log(tf.memory())\n"]}