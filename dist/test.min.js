let settings={activation:"relu",learningRate:.2,optimizer:"sgd",loss:"meanSquaredError"};function getModel(){const t=tf.sequential({layers:[tf.layers.dense({inputShape:[2],units:4,activation:settings.activation}),tf.layers.dense({units:1})]}),e=settings.learningRate,n=tf.train[settings.optimizer](e);return t.compile({optimizer:n,loss:tf.losses[settings.loss],metrics:["accuracy"]}),t}function randomizeWeights(t){let e=t.layers.length;for(let n=0;n<e;n++){let e=[];for(let i=0;i<2;i++){let s=t.layers[n].getWeights()[i],o=s.shape,r=s.dataSync().slice(),a=[...Array(r.length)].map(()=>2*Math.random()-1);e.push(tf.tensor(a,o))}t.layers[n].setWeights(e)}}tf.tidy(()=>{let t=getModel(),e=t.predict(tf.tensor([[0,1]]));console.log("prediction 1: "+e.dataSync()),e=t.predict(tf.tensor([[0,1]])),console.log("prediction 2: "+e.dataSync()),randomizeWeights(t),e=t.predict(tf.tensor([[0,1]])),console.log("prediction 3: "+e.dataSync()),randomizeWeights(t),e=t.predict(tf.tensor([[0,1]])),console.log("prediction 4: "+e.dataSync()),randomizeWeights(t),e=t.predict(tf.tensor([[0,1]])),console.log("prediction 5: "+e.dataSync())}),console.log(tf.memory());
//# sourceMappingURL=maps/test.min.js.map
